\chapter{Commande temps discret}
Afin d'implémenter la commande, nous avons dans un premier temps évaluer les contraintes lié au support d'implémentation et dans un second temps nous allons adapter la commande de façon à ce qu'elle soit implémentable sur le micro-contrôleur. Ensuite, nous évaluerons cette transformation. Voici, ci-dessous figure \ref{fig:GeneralSCHEMA}, le schéma général des différents éléments.	
\begin{figure}[!ht]
\centering 
\includegraphics[width=.7\textwidth]{./V/images/schemaMO_MICRO.pdf}
\caption{\label{fig:GeneralSCHEMA}Schéma des différents composants du montage.}
\end{figure}
On remarque qu'il y a 4 composants et le détail, non exhaustif, des éléments utiles de la carte \emph{microsys167-Eth}.
Le bloc nommé moteur correspond au banc moteur présent en salle de TP. Le bloc adaptateur de tension (Puissance) est la carte qui permet de passer de la tension de commande ($0$ à $5$ Volt) vers une tension adaptée au moteur ($-5$ à $5$ Volt).
\section{Contraintes hardware} 
Nous allons, dans cette partie, nous consacrer à une étude des contraintes matérielles. Dans un premier temps nous verrons quels sont les spécificités du micro-contrôleur. Puis, nous verrons les convertisseurs analogique/numérique et numérique/analogique et nous conclurons sur le choix du micro-contrôleur. 
	\subsection{Micro-contrôleur C167}
		%(ordo,taches,validation TR,temps calcul, fréquence fonctionnement)
Pour ce projet, nous disposons d'un micro-contrôleur \emph{C167} fabriqué par Siemens. Il est dans une carte \emph{microsys167-Eth} qui lui  ajoute des interfaces, des fonctionnalités et de la mémoire. La carte cadence le micro-contrôleur à $20\text{ }MHz$, ajoute un $1\text{ }Mo$ de RAM et $512\text{ } Ko$ de Flash-EPROM. Nous disposons aussi d'adaptateurs de tension ($\left[-5;5\right]$ Volt vers $\left[0;5\right]$ Volt). Le \emph{C167} offre différentes fonctionnalités, dont les interruptions matérielles, les taches, les timers périodiques et un débogueur. Nous avons également des outils de développement permettant depuis un ordinateur, de créer un programme en \emph{C}, le compiler pour le \emph{C167}, l'envoyer sur celui-ci et si besoin de le déboguer et récupérer des valeurs sur un terminal. La fréquence de fonctionnement du \emph{C167} est de $20 $ MHz et un cycle instruction faut 4 cycle CPU, donc la fréquence d'instruction est de $5 $ MHz.
Le \emph{C167} a également des entrées et des sorties numériques et analogiques. Nous allons maintenant vous parlez des problématiques de conversions.
	\subsection{CAN / CNA}
%		(protocole correction, temps conversion, échantillonnage bits )	

%%%% CAN			
Nous allons détailler deux types de conversions nécessaires à ce projet. \\
\hspace{3mm} \textbf{CAN :} (Conversion Analogique Numérique.) Durant cette opération, le convertisseur échantillonne grâce à un bloqueur (discrétisation temporelle) puis quantifie (discrétisation de l'amplitude) le signal analogique. Il restitue un signal numérique après un temps de conversion $t_{CAN}$. Nous avons besoin de ce type de convertisseur pour la lecture des entrées dans notre cas, $V_{D}$. La qualité de notre conversion dépend de plusieurs éléments : 
\begin{itemize}
\item Le nombre de bits de sortie (la sortie ne pouvant prendre que $2^{\text{nbrBit}}$ valeurs différentes). Nous avons des CAN 11 bits.
\item La fréquence de conversion du signal analogique $f_{e}$ par rapport à la fréquence utile maximale du signal a convertir $f_{max}$. Le théorème de Shannon préconise d'avoir au moins le rapport de l'équation \ref{equ:Fshannon}, en pratique nous respecterons le rapport de l'équation \ref{equ:Freel}. Cela évite le repliement.
\begin{eqnarray}
\label{equ:Fshannon} f_e &>& 2*f_{max}\\
\label{equ:Freel} f_e & \approx & 10*f_{max}
\end{eqnarray}
Nous avons considéré que la fréquence utile maximale de la position d'un moteur à courant continue est d'environ $f_{max} = 100Hz$. Nous avons donc prendre :
\begin{eqnarray}
f_e &=& 1\text{kHz}\\
\label{equ:Te} T_e &=& 1 \text{ms}\\
\end{eqnarray}
\item La conversion doit être linéaire. En effet, il existe différentes erreurs possibles. Il peut y avoir un offset, une erreur de gainn une non-linéarité intégrale ou différentielle (voir figure \ref{fig:errCAN}).
\end{itemize}
\begin{figure}[!ht]
\centering 
\includegraphics[width=.6\textwidth]{./V/images/CAN.pdf}
\caption{\label{fig:errCAN}Erreurs de conversions possibles sur le CAN}
\end{figure}
%%%% CNA 
\hspace{3mm} \textbf{CNA :} (Conversion Numérique Analogique.) Ici, le convertisseur transforme le signal numérique en un signal analogique après un temps de conversion $t_{CNA}$. Nous avons besoin de ce type de convertisseur pour la génération de la sortie dans notre cas, $V_{s}$. La qualité de notre conversion dépend de plusieurs éléments similaires au CAN. L'entrée du CNA est un entier codé sur 12 bits et il génère une tension comprise entre $-5$ et $5$ Volts. 


Par manque de temps, nous n'avons pas eu le temps mettre en place un protocole complet d'étude des erreurs de conversions, nous avons uniquement émis des valeurs avec le CNA et les avons lu avec le CAN afin que les valeurs mesurées et générées correspondent à peu prés à celles désirées. Nous avons fait ceci pour 1000 valeurs \ref{fig:errCAN}. On remarque qu'il y a deux saturations : avant $E1$ et après $E2$. Entre les deux, la conversion est à peu près constante. Cette approche présente l'avantage d'être rapide mais elle est néanmoins peu précise. En effet, les erreurs du CAN peuvent être masqués par le CNA et inversement. Elle ne permet non plus de savoir d'où vient le problème. 
\begin{figure}[!ht]
\begin{minipage}[t]{.48\textwidth}

\centering 		
\includegraphics[width=.9\textwidth]{./V/images/CAN_CNA_mesures_1.pdf}
\caption{\label{fig:errCAN}Erreurs de conversions entre le CAN et le CNA (pour le C167 n°1)}
\end{minipage}\hfill%
\begin{minipage}[t]{.48\textwidth}
\centering 		
\includegraphics[width=.9\textwidth]{./V/images/CAN_CNA_mesures.pdf}
\caption{\label{fig:errCAN}Erreurs de conversions entre le CAN et le CNA (pour le C167 n°2)}
\end{minipage}
\end{figure}
\newpage

Un protocole de test complet aurait été :\\
\begin{itemize}
\item Pour le CAN : 
	\begin{itemize}
		\item Générer, à partir d'un générateur de basse tension, un signal triangle de $0$ à $5$ Volt de fréquence faible.
		\item Lire toutes les valeurs et les faire afficher sur un terminal par le micro-contrôleur.
		\item Les comparer (à l'aide d'un tableur ou de Matlab) et vérifier la linéarité de la conversion.
		\item À partir des ces résultats, créer une fonction qui corrige les erreurs, si possible.
	\end{itemize}

\item Pour le CNA :
	\begin{itemize}
		\item Générer, à partir du micro-contrôleur un signal triangle de $-5$ à $5$ Volt de fréquence faible.
		\item Récupérer les valeurs à partir d'un CAN déjà corrigé (carte d'acquisition Matlab, ou le CAN précédemment si la correction donne de très bons résultats).
		\item Les comparer (à l'aide d'un tableur ou de Matlab) et vérifier la linéarité de la conversion.
		\item À partir des ces résultats, créer une fonction qui corrige les erreurs, si possible.
	\end{itemize}
\end{itemize}
\begin{eqnarray}
T_{CAN} &=& 14*t_{cc} + 2*t_{sc} + 4*TLC \\
&=&  9,7 \mu s%\\
%T_{CNA} &=& %% TODO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% /!\  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{eqnarray}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% /!\  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% /!\  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% /!\  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% /!\  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Conclusion}
	  	(contraintes tempo, squelette code correcteur)
	  	
	  	
	  	

\section{Discrétisation de la commande}
Nous allons à présent transformer la commande en temps continue en une forme qui permet l'implémentation sur un micro-contrôleur. Nous avons choisi de l'implémenter sous la forme d'une équation récurrente. Pour cela, dans un premier temps, nous avons transformer la commande (composée d'un observateur, d'un retour d'état et d'un pré-compensateur) en une forme espace d'états puis nous la discrétiserons. Ensuite, nous allons la transformer en une fonction de transfert pour finalement la transformer en équation récurrente.
	\subsection{Espace d'état à temps discret de la commande}
%		 (observateur + retour état = 2 ft)
%1. obs + re = EE
La commande est de la forme suivante (figure \ref{fig:comTC}) : 
\begin{figure}[!ht]
\centering
\includegraphics[width=.4\textwidth]{./V/images/Com_asserv.pdf}
\caption{\label{fig:comTC}Schéma de la commande par retour d'état à temps continue.}
\end{figure}


Voici, issue des équations \ref{equ:obs} et \ref{equ:obs2}, l'observateur simplifié (équation \ref{equ:obsSimp}).
\begin{equation}
\label{equ:obsSimp}
\left\lbrace
\begin{aligned}
&\dot z (t) = Fz(t) + GV_S(t) + Bu(t)\\
&\hat{x}(t) = z(t)
\end{aligned}
\right.
\end{equation}
Ainsi que le retour d'état :
\begin{equation}
u(t) = -K\hat{x}(t) + N V_{ref}(t)
\end{equation}
Nous allons rassembler ces équations afin de créer un nouvel espace d'état:
\begin{equation}
\begin{array}{ll}
&\left\lbrace
\begin{aligned}
&\dot z (t) = Fz(t) + GV_S(t) + Bu(t)\\
&u(t) = -Kz(t) + N V_{ref}(t)
\end{aligned}
\right.
\Leftrightarrow
\left\lbrace
\begin{aligned}
&\dot z (t) = (F-KB)z(t) + GV_S(t) + BN V_{ref}(t)\\
&u(t) = -Kz(t) + N V_{ref}(t)
\end{aligned}
\right.\\
&\\

\Leftrightarrow&
\left\lbrace
\begin{aligned}
&\dot z (t) = (F-KB)z(t) + 
\begin{bmatrix} G &  BN \end{bmatrix}  
\begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  
\\
&u(t) = -Kz(t) + 
\begin{bmatrix} N &  0 \end{bmatrix}  
\begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  
\end{aligned}
\right.
\end{array}
\end{equation}
%2. EE(z)
Maintenant que nous avons exprimer la commande sous la forme d'un espace d'état, avec pour entrées $V_{ref}(t)$ la consigne et $V_S(t)$, la sortie de position mesurée, nous pouvons discrétisé la commande. Nous avons choisis de discrétiser la commande grâce à matlab, avec l'option \emph{tustin} afin d'avoir une commande la plus fidèle possible à celle en temps continue.
Cela donne la commande à temps discret suivante :
\begin{equation}
\label{equ:EEcomTD}
\begin{array}{rl}
& \left\lbrace
\begin{array}{rclcl}
z(z-1) 	&=& A z(z) &+& B \begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  \\
u(z)  	&=& C z(z) &+& D \begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  
\end{array}
\right.\\
&\\
\Leftrightarrow &
\left\lbrace
\begin{array}{rclcclc}
z(z-1) 	&=& 
\begin{bmatrix}
0.7679 		&  0.03725\\
-0.00193   	& 0.6207
\end{bmatrix} &z(z) 
&+& \begin{bmatrix}
0.08301  &  0.2089\\
3.612  	 &	0.001737
\end{bmatrix} 
&\begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  \\
u(z)  	&=& \begin{bmatrix}
8.589*10^{-05}  &  -0.07211
\end{bmatrix} &z(z) &+& \begin{bmatrix}
1.35  & -7.73*10^{-05}
\end{bmatrix} 
&\begin{bmatrix} V_S(t) \\ V_{ref}(t)  \end{bmatrix}  
\end{array}
\right.
\end{array}
\end{equation}
	\subsection{Équation récurrente}
%1. EE 		= 2*tf(z)
	Nous allons maintenant transformer l'espace d'état de l'équation \ref{equ:EEcomTD} en fonctions de transferts, à l'aide de matlab :
\begin{eqnarray}
\frac{u(z)}{V_s(z)} &=& \frac{1.35 z^2 - 2.135 z + 0.8435}{    z^2 - 1.389 z + 0.4767}\\
\frac{u(z)}{V_{ref}(z)}	&=&	\frac{-7.73*10^{-05} z^2 - 8.582*10^{-21} z + 7.73*10^{-05}}{z^2 - 1.389 z + 0.4767}
\end{eqnarray}

%2. 2*tf(z) = 1*tf(z^-1)

Afin d'avoir une commande causale, nous avons passer les fonctions de transferts en $z^{-1}$ :
\begin{eqnarray}
\label{equ:ftTD1}\frac{u(z^{-1})}{V_s(z^{-1})} &=& \frac{1.35  - 2.135 z^{-1} + 0.8435 z^{-2}}{    1 - 1.389 z^{-1} + 0.4767 z^{-2}}\\
\label{equ:ftTD2}\frac{u(z^{-1})}{V_{ref}(z^{-1})}	&=&	\frac{-7.73*10^{-05} - 8.582*10^{-21} z^{-1} + 7.73*10^{-05} z^{-2}}{    1 - 1.389 z^{-1} + 0.4767 z^{-2}}
\end{eqnarray}
Nous avons ensuite, à partir des équations \ref{equ:ftTD1} et  \ref{equ:ftTD2}, créer une seule équation :
\begin{equation}
\label{equ:eqTDz-}
\begin{array}{lcl}
u(z^{-1})(1 - 1.389 z^{-1} + 0.4767 z^{-2}) &=& (1.35  - 2.135 z^{-1} + 0.8435 z^{-2})  V_s(z^{-1}) \\
&&+ (-7.73*10^{-05} - 8.582*10^{-21} z^{-1} + 7.73*10^{-05} z^{-2})V_{ref}(z^{-1})
\end{array}
\end{equation}
Nous avons maintenant une seule équation pour représenter la commande à temps discret.%
%3. tf(z^-1)= ER(z^-1)
Il faut maintenant la transformée en équation récurrente, pour cela nous allons utiliser la propriété suivante :
\begin{equation}
f(z)z^n = f_{k+n}
\end{equation}
Cela donne, une fois réorganiser de façon a isoler la sortie $u_k$ et à partir de l'équation \ref{equ:eqTDz-} :
\begin{equation}
\begin{array}{lcl}
u_k &=&  1.389 u_{k-1} - 0.4767 u_{k-2} + 1.35Vs_{k}  - 2.135 Vs_{k-1} + 0.8435 Vs_{k-2}  \\
&& -7.73*10^{-05}Vr_k - 8.582*10^{-21} Vr_{k-1} + 7.73*10^{-05} Vr_{k-2}
\end{array}
\end{equation}
Où,par soucis de lisibilité, $Vs = V_s$ et $Vr = V_{ref}$.
Le coût temporel de ce calcul est au minimum de $8*400ns = 3,2 ms$.
Maintenant que nous avons une équation implémentable sur micro contrôleur, il faut créer un code le permettant, à partir de celui fourni.
